{"version":3,"sources":["menu/menu-trigger.ts"],"names":[],"mappings":"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","file":"menu-trigger.js","sourcesContent":["import {\n    AfterViewInit,\n    Directive,\n    ElementRef,\n    EventEmitter,\n    Input,\n    OnDestroy,\n    Optional,\n    Output,\n    Renderer,\n    ViewContainerRef,\n} from '@angular/core';\nimport {MdMenuPanel} from './menu-panel';\nimport {MdMenuMissingError} from './menu-errors';\nimport {\n    isFakeMousedownFromScreenReader,\n    Dir,\n    LayoutDirection,\n    Overlay,\n    OverlayState,\n    OverlayRef,\n    TemplatePortal,\n    ConnectedPositionStrategy,\n    HorizontalConnectionPos,\n    VerticalConnectionPos,\n} from '../core';\nimport {Subscription} from 'rxjs/Subscription';\nimport {MenuPositionX, MenuPositionY} from './menu-positions';\n\n/**\n * This directive is intended to be used in conjunction with an md-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\n@Directive({\n  selector: '[md-menu-trigger-for], [mat-menu-trigger-for], [mdMenuTriggerFor]',\n  host: {\n    'aria-haspopup': 'true',\n    '(mousedown)': '_handleMousedown($event)',\n    '(click)': 'toggleMenu()',\n  },\n  exportAs: 'mdMenuTrigger'\n})\nexport class MdMenuTrigger implements AfterViewInit, OnDestroy {\n  private _portal: TemplatePortal;\n  private _overlayRef: OverlayRef;\n  private _menuOpen: boolean = false;\n  private _backdropSubscription: Subscription;\n  private _positionSubscription: Subscription;\n\n  // tracking input type is necessary so it's possible to only auto-focus\n  // the first item of the list when the menu is opened via the keyboard\n  private _openedByMouse: boolean = false;\n\n  /** @deprecated */\n  @Input('md-menu-trigger-for')\n  get _deprecatedMenuTriggerFor(): MdMenuPanel { return this.menu; }\n  set _deprecatedMenuTriggerFor(v: MdMenuPanel) { this.menu = v; }\n\n  /** References the menu instance that the trigger is associated with. */\n  @Input('mdMenuTriggerFor') menu: MdMenuPanel;\n\n  /** Event emitted when the associated menu is opened. */\n  @Output() onMenuOpen = new EventEmitter<void>();\n\n  /** Event emitted when the associated menu is closed. */\n  @Output() onMenuClose = new EventEmitter<void>();\n\n  constructor(private _overlay: Overlay, private _element: ElementRef,\n              private _viewContainerRef: ViewContainerRef, private _renderer: Renderer,\n              @Optional() private _dir: Dir) {}\n\n  ngAfterViewInit() {\n    this._checkMenu();\n    this.menu.close.subscribe(() => this.closeMenu());\n  }\n\n  ngOnDestroy() { this.destroyMenu(); }\n\n  /** Whether the menu is open. */\n  get menuOpen(): boolean { return this._menuOpen; }\n\n  /** Toggles the menu between the open and closed states. */\n  toggleMenu(): void {\n    return this._menuOpen ? this.closeMenu() : this.openMenu();\n  }\n\n  /** Opens the menu. */\n  openMenu(): void {\n    if (!this._menuOpen) {\n      this._createOverlay();\n      this._overlayRef.attach(this._portal);\n      this._subscribeToBackdrop();\n      this._initMenu();\n    }\n  }\n\n  /** Closes the menu. */\n  closeMenu(): void {\n    if (this._overlayRef) {\n      this._overlayRef.detach();\n      this._backdropSubscription.unsubscribe();\n      this._resetMenu();\n    }\n  }\n\n  /** Removes the menu from the DOM. */\n  destroyMenu(): void {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n\n      this._cleanUpSubscriptions();\n    }\n  }\n\n  /** Focuses the menu trigger. */\n  focus() {\n    this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');\n  }\n\n  /** The text direction of the containing app. */\n  get dir(): LayoutDirection {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /**\n   * This method ensures that the menu closes when the overlay backdrop is clicked.\n   * We do not use first() here because doing so would not catch clicks from within\n   * the menu, and it would fail to unsubscribe properly. Instead, we unsubscribe\n   * explicitly when the menu is closed or destroyed.\n   */\n  private _subscribeToBackdrop(): void {\n    this._backdropSubscription = this._overlayRef.backdropClick().subscribe(() => {\n      this.closeMenu();\n    });\n  }\n\n  /**\n   * This method sets the menu state to open and focuses the first item if\n   * the menu was opened via the keyboard.\n   */\n  private _initMenu(): void {\n    this._setIsMenuOpen(true);\n\n    // Should only set focus if opened via the keyboard, so keyboard users can\n    // can easily navigate menu items. According to spec, mouse users should not\n    // see the focus style.\n    if (!this._openedByMouse) {\n      this.menu.focusFirstItem();\n    }\n  };\n\n  /**\n   * This method resets the menu when it's closed, most importantly restoring\n   * focus to the menu trigger if the menu was opened via the keyboard.\n   */\n  private _resetMenu(): void {\n    this._setIsMenuOpen(false);\n\n    // Focus only needs to be reset to the host element if the menu was opened\n    // by the keyboard and manually shifted to the first menu item.\n    if (!this._openedByMouse) {\n      this.focus();\n    }\n    this._openedByMouse = false;\n  }\n\n  // set state rather than toggle to support triggers sharing a menu\n  private _setIsMenuOpen(isOpen: boolean): void {\n    this._menuOpen = isOpen;\n    this._menuOpen ? this.onMenuOpen.emit() : this.onMenuClose.emit();\n  }\n\n  /**\n   *  This method checks that a valid instance of MdMenu has been passed into\n   *  mdMenuTriggerFor. If not, an exception is thrown.\n   */\n  private _checkMenu() {\n    if (!this.menu) {\n      throw new MdMenuMissingError();\n    }\n  }\n\n  /**\n   *  This method creates the overlay from the provided menu's template and saves its\n   *  OverlayRef so that it can be attached to the DOM when openMenu is called.\n   */\n  private _createOverlay(): void {\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n      const config = this._getOverlayConfig();\n      this._subscribeToPositions(config.positionStrategy as ConnectedPositionStrategy);\n      this._overlayRef = this._overlay.create(config);\n    }\n  }\n\n  /**\n   * This method builds the configuration object needed to create the overlay, the OverlayState.\n   * @returns OverlayState\n   */\n  private _getOverlayConfig(): OverlayState {\n    const overlayState = new OverlayState();\n    overlayState.positionStrategy = this._getPosition()\n                                        .withDirection(this.dir);\n    overlayState.hasBackdrop = true;\n    overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';\n    overlayState.direction = this.dir;\n    return overlayState;\n  }\n\n  /**\n   * Listens to changes in the position of the overlay and sets the correct classes\n   * on the menu based on the new position. This ensures the animation origin is always\n   * correct, even if a fallback position is used for the overlay.\n   */\n  private _subscribeToPositions(position: ConnectedPositionStrategy): void {\n    this._positionSubscription = position.onPositionChange.subscribe((change) => {\n      const posX: MenuPositionX = change.connectionPair.originX === 'start' ? 'after' : 'before';\n      const posY: MenuPositionY = change.connectionPair.originY === 'top' ? 'below' : 'above';\n      this.menu.setPositionClasses(posX, posY);\n    });\n  }\n\n  /**\n   * This method builds the position strategy for the overlay, so the menu is properly connected\n   * to the trigger.\n   * @returns ConnectedPositionStrategy\n   */\n  private _getPosition(): ConnectedPositionStrategy  {\n    const [posX, fallbackX]: HorizontalConnectionPos[] =\n      this.menu.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];\n\n    const [posY, fallbackY]: VerticalConnectionPos[] =\n      this.menu.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n\n    return this._overlay.position()\n      .connectedTo(this._element,\n          {originX: posX, originY: posY}, {overlayX: posX, overlayY: posY})\n      .withFallbackPosition(\n          {originX: fallbackX, originY: posY},\n          {overlayX: fallbackX, overlayY: posY})\n      .withFallbackPosition(\n          {originX: posX, originY: fallbackY},\n          {overlayX: posX, overlayY: fallbackY})\n      .withFallbackPosition(\n          {originX: fallbackX, originY: fallbackY},\n          {overlayX: fallbackX, overlayY: fallbackY});\n  }\n\n  private _cleanUpSubscriptions(): void {\n    if (this._backdropSubscription) {\n      this._backdropSubscription.unsubscribe();\n    }\n    if (this._positionSubscription) {\n      this._positionSubscription.unsubscribe();\n    }\n  }\n\n  _handleMousedown(event: MouseEvent): void {\n    if (!isFakeMousedownFromScreenReader(event)) {\n      this._openedByMouse = true;\n    }\n  }\n\n}\n"]}