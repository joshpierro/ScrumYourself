{"version":3,"sources":["snack-bar/snack-bar-container.ts"],"names":[],"mappings":";;;;;;;;;;;;;;OAAO,EACL,SAAS,EAET,SAAS,EACT,OAAO,EACP,KAAK,EACL,KAAK,EACL,UAAU,EACV,OAAO,EAEP,MAAM,EAEP,MAAM,eAAe;OACf,EACL,cAAc,EAGd,mBAAmB,EACpB,MAAM,SAAS;OAET,EAAC,gCAAgC,EAAC,MAAM,oBAAoB;OAE5D,EAAC,OAAO,EAAC,MAAM,cAAc;AAMpC,sFAAsF;AACtF,2FAA2F;AAC3F,OAAO,IAAM,cAAc,GAAG,iCAAiC,CAAC;AAChE,OAAO,IAAM,cAAc,GAAG,mCAAmC,CAAC;AAElE;;;GAGG;AAqBH;IAAyC,uCAAc;IAgBrD,6BAAoB,OAAe;QACjC,iBAAO,CAAC;QADU,YAAO,GAAP,OAAO,CAAQ;QAZnC,qEAAqE;QAC7D,WAAM,GAAiB,IAAI,OAAO,EAAE,CAAC;QAE7C,+EAA+E;QACvE,YAAO,GAAiB,IAAI,OAAO,EAAE,CAAC;QAE9C,6CAA6C;QAC7C,mBAAc,GAAkB,SAAS,CAAC;IAO1C,CAAC;IAED,wEAAwE;IACxE,mDAAqB,GAArB,UAAyB,MAA0B;QACjD,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;YACnC,MAAM,IAAI,gCAAgC,EAAE,CAAC;QAC/C,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;IACxD,CAAC;IAED,uEAAuE;IACvE,kDAAoB,GAApB,UAAqB,MAAsB;QACzC,MAAM,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACrC,CAAC;IAED,oEAAoE;IACpE,4CAAc,GAAd,UAAe,KAA+B;QAA9C,iBAaC;QAZC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,MAAM,IAAI,KAAK,CAAC,OAAO,KAAK,UAAU,CAAC,CAAC,CAAC;YAC7D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;gBACf,KAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;gBACnB,KAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YACzB,CAAC,CAAC,CAAC;QACL,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC;YAChC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;gBACf,KAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;gBACpB,KAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAC1B,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,uDAAuD;IACvD,mCAAK,GAAL;QACE,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;IAClC,CAAC;IAED,2EAA2E;IAC3E,sCAAQ,GAAR;QACE,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;IACrC,CAAC;IAED,0DAA0D;IAC1D,kCAAI,GAAJ;QACE,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC;QACjC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;IACxB,CAAC;IAED,gFAAgF;IAChF,qCAAO,GAAP;QACE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;IACpC,CAAC;IAED;;OAEG;IACH,yCAAW,GAAX;QAAA,iBAOC;QANC,yEAAyE;QACzE,qFAAqF;QACrF,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC,SAAS,CAAC;YAC9C,KAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACnB,KAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IAhFD;QAAC,SAAS,CAAC,mBAAmB,CAAC;;4DAAA;IAtBjC;QAAC,SAAS,CAAC;YACT,QAAQ,EAAE,MAAM,CAAC,EAAE;YACnB,QAAQ,EAAE,qBAAqB;YAC/B,WAAW,EAAE,0BAA0B;YACvC,SAAS,EAAE,CAAC,yBAAyB,CAAC;YACtC,IAAI,EAAE;gBACJ,MAAM,EAAE,OAAO;gBACf,UAAU,EAAE,gBAAgB;gBAC5B,eAAe,EAAE,wBAAwB;aAC1C;YACD,UAAU,EAAE;gBACV,OAAO,CAAC,OAAO,EAAE;oBACf,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,EAAC,SAAS,EAAE,kBAAkB,EAAC,CAAC,CAAC;oBACxD,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,EAAC,SAAS,EAAE,gBAAgB,EAAC,CAAC,CAAC;oBACtD,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,EAAC,SAAS,EAAE,kBAAkB,EAAC,CAAC,CAAC;oBACzD,UAAU,CAAC,qBAAqB,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;oBAC1D,UAAU,CAAC,qCAAqC,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;iBAC3E,CAAC;aACH;SACF,CAAC;;2BAAA;IAoFF,0BAAC;AAAD,CAnFA,AAmFC,CAnFwC,cAAc,GAmFtD","file":"snack-bar-container.js","sourcesContent":["import {\n  Component,\n  ComponentRef,\n  ViewChild,\n  trigger,\n  state,\n  style,\n  transition,\n  animate,\n  AnimationTransitionEvent,\n  NgZone,\n  OnDestroy,\n} from '@angular/core';\nimport {\n  BasePortalHost,\n  ComponentPortal,\n  TemplatePortal,\n  PortalHostDirective,\n} from '../core';\nimport {MdSnackBarConfig} from './snack-bar-config';\nimport {MdSnackBarContentAlreadyAttached} from './snack-bar-errors';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\n\n\n\nexport type SnackBarState = 'initial' | 'visible' | 'complete' | 'void';\n\n// TODO(jelbourn): we can't use constants from animation.ts here because you can't use\n// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).\nexport const SHOW_ANIMATION = '225ms cubic-bezier(0.4,0.0,1,1)';\nexport const HIDE_ANIMATION = '195ms cubic-bezier(0.0,0.0,0.2,1)';\n\n/**\n * Internal component that wraps user-provided snack bar content.\n * @docs-private\n */\n@Component({\n  moduleId: module.id,\n  selector: 'snack-bar-container',\n  templateUrl: 'snack-bar-container.html',\n  styleUrls: ['snack-bar-container.css'],\n  host: {\n    'role': 'alert',\n    '[@state]': 'animationState',\n    '(@state.done)': 'onAnimationEnd($event)'\n  },\n  animations: [\n    trigger('state', [\n      state('initial', style({transform: 'translateY(100%)'})),\n      state('visible', style({transform: 'translateY(0%)'})),\n      state('complete', style({transform: 'translateY(100%)'})),\n      transition('visible => complete', animate(HIDE_ANIMATION)),\n      transition('initial => visible, void => visible', animate(SHOW_ANIMATION)),\n    ])\n  ],\n})\nexport class MdSnackBarContainer extends BasePortalHost implements OnDestroy {\n  /** The portal host inside of this container into which the snack bar content will be loaded. */\n  @ViewChild(PortalHostDirective) _portalHost: PortalHostDirective;\n\n  /** Subject for notifying that the snack bar has exited from view. */\n  private onExit: Subject<any> = new Subject();\n\n  /** Subject for notifying that the snack bar has finished entering the view. */\n  private onEnter: Subject<any> = new Subject();\n\n  /** The state of the snack bar animations. */\n  animationState: SnackBarState = 'initial';\n\n  /** The snack bar configuration. */\n  snackBarConfig: MdSnackBarConfig;\n\n  constructor(private _ngZone: NgZone) {\n    super();\n  }\n\n  /** Attach a component portal as content to this snack bar container. */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    if (this._portalHost.hasAttached()) {\n      throw new MdSnackBarContentAlreadyAttached();\n    }\n\n    return this._portalHost.attachComponentPortal(portal);\n  }\n\n  /** Attach a template portal as content to this snack bar container. */\n  attachTemplatePortal(portal: TemplatePortal): Map<string, any> {\n    throw Error('Not yet implemented');\n  }\n\n  /** Handle end of animations, updating the state of the snackbar. */\n  onAnimationEnd(event: AnimationTransitionEvent) {\n    if (event.toState === 'void' || event.toState === 'complete') {\n      this._ngZone.run(() => {\n        this.onExit.next();\n        this.onExit.complete();\n      });\n    }\n    if (event.toState === 'visible') {\n      this._ngZone.run(() => {\n        this.onEnter.next();\n        this.onEnter.complete();\n      });\n    }\n  }\n\n  /** Begin animation of snack bar entrance into view. */\n  enter(): void {\n    this.animationState = 'visible';\n  }\n\n  /** Returns an observable resolving when the enter animation completes.  */\n  _onEnter(): Observable<void> {\n    this.animationState = 'visible';\n    return this.onEnter.asObservable();\n  }\n\n  /** Begin animation of the snack bar exiting from view. */\n  exit(): Observable<void> {\n    this.animationState = 'complete';\n    return this._onExit();\n  }\n\n  /** Returns an observable that completes after the closing animation is done. */\n  _onExit(): Observable<void> {\n    return this.onExit.asObservable();\n  }\n\n  /**\n   * Makes sure the exit callbacks have been invoked when the element is destroyed.\n   */\n  ngOnDestroy() {\n    // Wait for the zone to settle before removing the element. Helps prevent\n    // errors where we end up removing an element which is in the middle of an animation.\n    this._ngZone.onMicrotaskEmpty.first().subscribe(() => {\n      this.onExit.next();\n      this.onExit.complete();\n    });\n  }\n}\n"]}